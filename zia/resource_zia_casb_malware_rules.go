package zia

import (
	"context"
	"fmt"
	"log"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
	"github.com/zscaler/zscaler-sdk-go/v3/zscaler/errorx"
	"github.com/zscaler/zscaler-sdk-go/v3/zscaler/zia/services/saas_security_api/casb_malware_rules"
)

var (
	cloudCasbMalwareRuleLock          sync.Mutex
	cloudCasbMalwareRulestartingOrder int
)

func resourceCasbMalwareRules() *schema.Resource {
	return &schema.Resource{
		CreateContext: resourceCasbMalwareRulesCreate,
		ReadContext:   resourceCasbMalwareRulesRead,
		UpdateContext: resourceCasbMalwareRulesUpdate,
		DeleteContext: resourceCasbMalwareRulesDelete,
		Timeouts: &schema.ResourceTimeout{
			Create: schema.DefaultTimeout(60 * time.Minute),
			Update: schema.DefaultTimeout(60 * time.Minute),
		},
		Importer: &schema.ResourceImporter{
			StateContext: func(ctx context.Context, d *schema.ResourceData, meta interface{}) ([]*schema.ResourceData, error) {
				zClient := meta.(*Client)
				service := zClient.Service

				id := d.Id()
				var ruleType, identifier string

				// Check if id contains a colon to split rule type and identifier
				if strings.Contains(id, ":") {
					parts := strings.SplitN(id, ":", 2)
					ruleType = parts[0]
					identifier = parts[1]
				} else {
					// If no colon, treat entire id as the identifier (assuming it's the rule ID for now)
					return nil, fmt.Errorf("invalid import format: expected 'rule_type:rule_id' or 'rule_type:rule_name'")
				}

				// Check if the identifier is a rule ID
				idInt, parseIDErr := strconv.Atoi(identifier)
				if parseIDErr == nil {
					// If identifier is an ID
					resp, err := casb_malware_rules.GetByRuleID(ctx, service, ruleType, idInt)
					if err != nil {
						return nil, err
					}
					d.SetId(strconv.Itoa(resp.ID))
					_ = d.Set("rule_id", resp.ID)
					_ = d.Set("type", ruleType)
				} else {
					// If identifier is a name
					resources, err := casb_malware_rules.GetByRuleType(ctx, service, ruleType)
					if err != nil {
						return nil, err
					}
					for _, r := range resources {
						if r.Name == identifier {
							d.SetId(strconv.Itoa(r.ID))
							_ = d.Set("rule_id", r.ID)
							_ = d.Set("type", ruleType)
							break
						}
					}
					if d.Id() == "" {
						return nil, fmt.Errorf("couldn't find any casb malware rule with name '%s'", identifier)
					}
				}
				return []*schema.ResourceData{d}, nil
			},
		},

		Schema: map[string]*schema.Schema{
			"id": {
				Type:        schema.TypeString,
				Computed:    true,
				Description: "A unique identifier assigned to the forwarding rule",
			},
			"rule_id": {
				Type:        schema.TypeInt,
				Computed:    true,
				Description: "A unique identifier assigned to the forwarding rule",
			},
			"name": {
				Type:     schema.TypeString,
				Optional: true,
			},
			"type": {
				Type:     schema.TypeString,
				Optional: true,
				ValidateFunc: validation.StringInSlice([]string{
					"ANY",
					"NONE",
					"OFLCASB_AVP_FILE",
					"OFLCASB_AVP_EMAIL",
					"OFLCASB_AVP_CRM",
					"OFLCASB_AVP_ITSM",
					"OFLCASB_AVP_COLLAB",
					"OFLCASB_AVP_REPO",
					"OFLCASB_AVP_STORAGE",
					"OFLCASB_AVP_GENAI",
				}, false),
			},
			"order": {
				Type:     schema.TypeInt,
				Optional: true,
			},
			"state": {
				Type:     schema.TypeString,
				Optional: true,
				Default:  "ENABLED",
				ValidateFunc: validation.StringInSlice([]string{
					"ENABLED",
					"DISABLED",
				}, false),
			},
			"action": {
				Type:     schema.TypeString,
				Optional: true,
				ValidateFunc: validation.StringInSlice([]string{
					"OFLCASB_AVP_QUARANTINE",
					"OFLCASB_AVP_REMOVE",
					"OFLCASB_AVP_REPORT_MALWARE",
					"OFLCASB_AVP_APPLY_EMAIL_TAG",
					"OFLCASB_AVP_BLOCK",
					"OFLCASB_AVP_ALLOW",
				}, false),
			},
			"quarantine_location": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "Location where all the quarantined files are moved and necessary actions are taken by either deleting or restoring the data",
			},
			"scan_inbound_email_link": {
				Type:        schema.TypeString,
				Optional:    true,
				Description: "Enables or disables the scan inbound email link",
				ValidateFunc: validation.StringInSlice([]string{
					"SCAN_EMAIL_LINK_ENABLE",
					"SCAN_EMAIL_LINK_DISABLE",
				}, false),
			},
			"cloud_app_tenants":       setIDsSchemaTypeCustom(intPtr(1), "Name-ID pairs of the cloud application tenants for which the rule is applied. If the name-ID pairs of the cloud application tenants are not specified, the rule is applied to all tenants."),
			"cloud_app_tenant_ids":    setIDsSchemaTypeCustom(intPtr(1), "This field is applicable for devices that are managed using Zscaler Client Connector."),
			"labels":                  setIDsSchemaTypeCustom(intPtr(1), "list of Labels that are applicable to the rule."),
			"buckets":                 setIDsSchemaTypeCustom(intPtr(8), "Name-ID pairs of locations for which rule must be applied"),
			"casb_email_label":        setSingleIDSchemaTypeCustom("The ZPA Server Group for which this rule is applicable. Only the Server Groups that are associated with the selected Application Segments are allowed. This field is applicable only for the ZPA forwarding method."),
			"casb_tombstone_template": setSingleIDSchemaTypeCustom("The ZPA Server Group for which this rule is applicable. Only the Server Groups that are associated with the selected Application Segments are allowed. This field is applicable only for the ZPA forwarding method."),
		},
	}
}

func resourceCasbMalwareRulesCreate(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	zClient := meta.(*Client)
	service := zClient.Service

	req := expandCasbMalwareRules(d)
	log.Printf("[INFO] Creating zia casb malware rules\n%+v\n", req)

	timeout := d.Timeout(schema.TimeoutCreate)
	start := time.Now()

	for {
		cloudCasbMalwareRuleLock.Lock()
		if cloudCasbMalwareRulestartingOrder == 0 {
			rules, _ := casb_malware_rules.GetByRuleType(ctx, service, req.Type)
			for _, r := range rules {
				if r.Order > cloudCasbMalwareRulestartingOrder {
					cloudCasbMalwareRulestartingOrder = r.Order
				}
			}
			if cloudCasbMalwareRulestartingOrder == 0 {
				cloudCasbMalwareRulestartingOrder = 1
			}
		}
		cloudCasbMalwareRuleLock.Unlock()
		startWithoutLocking := time.Now()

		order := req.Order
		req.Order = cloudCasbMalwareRulestartingOrder

		resp, err := casb_malware_rules.Create(ctx, service, &req)

		// Fail immediately if INVALID_INPUT_ARGUMENT is detected
		if customErr := failFastOnErrorCodes(err); customErr != nil {
			return diag.Errorf("%v", customErr)
		}

		if err != nil {
			if strings.Contains(err.Error(), "INVALID_INPUT_ARGUMENT") {
				log.Printf("[INFO] Creating casb malware rules name: %v, got INVALID_INPUT_ARGUMENT\n", req.Name)
				if time.Since(start) < timeout {
					time.Sleep(10 * time.Second) // Wait before retrying
					continue
				}
			}
			return diag.Errorf("error creating resource: %v", err)
		}

		log.Printf("[INFO] Created zia casb malware rules request. took:%s, without locking:%s,  ID: %v\n", time.Since(start), time.Since(startWithoutLocking), resp)
		reorder(order, resp.ID, "casb_malware_rules", func() (int, error) {
			rules, err := casb_malware_rules.GetByRuleType(ctx, service, req.Type)
			return len(rules), err
		}, func(id, order int) error {
			rule, err := casb_malware_rules.GetByRuleID(ctx, service, req.Type, id)
			if err != nil {
				return fmt.Errorf("failed to retrieve rule by ID: %v", err)
			}
			rule.Order = order
			_, err = casb_malware_rules.Update(ctx, service, id, rule)

			if err != nil {
				return fmt.Errorf("failed to update rule order: %v", err)
			}
			return nil
		})

		d.SetId(strconv.Itoa(resp.ID))
		_ = d.Set("rule_id", resp.ID)

		if diags := resourceCasbMalwareRulesRead(ctx, d, meta); diags.HasError() {
			if time.Since(start) < timeout {
				time.Sleep(10 * time.Second)
				continue
			}
			return diags
		}
		markOrderRuleAsDone(resp.ID, "casb_malware_rules")
		break
	}

	// Sleep for 2 seconds before potentially triggering the activation
	time.Sleep(2 * time.Second)

	// Check if ZIA_ACTIVATION is set to a truthy value before triggering activation
	if shouldActivate() {
		if activationErr := triggerActivation(ctx, zClient); activationErr != nil {
			return diag.FromErr(activationErr)
		}
	} else {
		log.Printf("[INFO] Skipping configuration activation due to ZIA_ACTIVATION env var not being set to true.")
	}

	return resourceCasbMalwareRulesRead(ctx, d, meta)
}

func resourceCasbMalwareRulesRead(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	zClient := meta.(*Client)
	service := zClient.Service

	id, ok := getIntFromResourceData(d, "rule_id")
	if !ok {
		return diag.FromErr(fmt.Errorf("no zia casb malware rules id is set"))
	}
	ruleType, ok := d.Get("type").(string)
	if !ok || ruleType == "" {
		return diag.FromErr(fmt.Errorf("no rule type is set"))
	}
	resp, err := casb_malware_rules.GetByRuleID(ctx, service, ruleType, id)
	if err != nil {
		if respErr, ok := err.(*errorx.ErrorResponse); ok && respErr.IsObjectNotFound() {
			log.Printf("[WARN] Removing casb malware rules %s from state because it no longer exists in ZIA", d.Id())
			d.SetId("")
			return nil
		}

		return diag.FromErr(err)
	}

	log.Printf("[INFO] Getting casb malware rules:\n%+v\n", resp)

	d.SetId(fmt.Sprintf("%d", resp.ID))
	_ = d.Set("name", resp.Name)
	_ = d.Set("type", resp.Type)
	_ = d.Set("order", resp.Order)
	_ = d.Set("state", resp.State)
	_ = d.Set("action", resp.Action)
	_ = d.Set("quarantine_location", resp.QuarantineLocation)
	_ = d.Set("scan_inbound_email_link", resp.ScanInboundEmailLink)

	if err := d.Set("buckets", flattenIDExtensionsListIDs(resp.Buckets)); err != nil {
		return diag.FromErr(err)
	}

	if err := d.Set("labels", flattenIDExtensionsListIDs(resp.Labels)); err != nil {
		return diag.FromErr(err)
	}
	if err := d.Set("cloud_app_tenant_ids", flattenIDExtensionsListIDs(resp.CloudAppTenantIDs)); err != nil {
		return diag.FromErr(err)
	}
	if err := d.Set("cloud_app_tenants", flattenIDExtensionsListIDs(resp.CloudAppTenants)); err != nil {
		return diag.FromErr(err)
	}
	if err := d.Set("casb_tombstone_template", flattenCustomIDSet(resp.CasbTombstoneTemplate)); err != nil {
		return diag.FromErr(err)
	}

	return nil
}

func resourceCasbMalwareRulesUpdate(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	zClient := meta.(*Client)
	service := zClient.Service

	id, ok := getIntFromResourceData(d, "rule_id")
	if !ok {
		log.Printf("[ERROR] casb malware rules ID not set: %v\n", id)
		return diag.Errorf("casb malware rules ID not set")
	}

	ruleType, ok := d.Get("type").(string)
	if !ok || ruleType == "" {
		return diag.Errorf("no rule type is set")
	}

	log.Printf("[INFO] Updating zia casb malware rules ID: %v\n", id)
	req := expandCasbMalwareRules(d)

	if _, err := casb_malware_rules.GetByRuleID(ctx, service, ruleType, id); err != nil {
		if respErr, ok := err.(*errorx.ErrorResponse); ok && respErr.IsObjectNotFound() {
			d.SetId("")
			return nil
		}
	}

	timeout := d.Timeout(schema.TimeoutUpdate)
	start := time.Now()

	for {
		_, err := casb_malware_rules.Update(ctx, service, id, &req)

		// Fail immediately if INVALID_INPUT_ARGUMENT is detected
		if customErr := failFastOnErrorCodes(err); customErr != nil {
			return diag.Errorf("%v", customErr)
		}

		if err != nil {
			if strings.Contains(err.Error(), "INVALID_INPUT_ARGUMENT") {
				log.Printf("[INFO] Updating casb malware rules ID: %v, got INVALID_INPUT_ARGUMENT\n", id)
				if time.Since(start) < timeout {
					time.Sleep(10 * time.Second) // Wait before retrying
					continue
				}
			}
			return diag.Errorf("error updating resource: %v", err)
		}

		reorder(req.Order, req.ID, "casb_malware_rules", func() (int, error) {
			rules, err := casb_malware_rules.GetByRuleType(ctx, service, req.Type)
			return len(rules), err
		}, func(id, order int) error {
			rule, err := casb_malware_rules.GetByRuleID(ctx, service, req.Type, id)
			if err != nil {
				return fmt.Errorf("failed to retrieve rule by ID: %v", err)
			}
			rule.Order = order
			_, err = casb_malware_rules.Update(ctx, service, id, rule)

			if err != nil {
				return fmt.Errorf("failed to update rule order: %v", err)
			}
			return nil
		})

		if diags := resourceCasbMalwareRulesRead(ctx, d, meta); diags.HasError() {
			if time.Since(start) < timeout {
				time.Sleep(10 * time.Second) // Wait before retrying
				continue
			}
			return diags
		}
		markOrderRuleAsDone(req.ID, "casb_malware_rules")
		break
	}

	// Sleep for 2 seconds before potentially triggering the activation
	time.Sleep(2 * time.Second)

	// Check if ZIA_ACTIVATION is set to a truthy value before triggering activation
	if shouldActivate() {
		if activationErr := triggerActivation(ctx, zClient); activationErr != nil {
			return diag.FromErr(activationErr)
		}
	} else {
		log.Printf("[INFO] Skipping configuration activation due to ZIA_ACTIVATION env var not being set to true.")
	}

	return resourceCasbMalwareRulesRead(ctx, d, meta)
}

func resourceCasbMalwareRulesDelete(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	zClient := meta.(*Client)
	service := zClient.Service

	id, ok := getIntFromResourceData(d, "rule_id")
	if !ok {
		log.Printf("[ERROR] casb malware rules not set: %v\n", id)
	}
	ruleType, ok := d.Get("type").(string)
	if !ok || ruleType == "" {
		return diag.FromErr(fmt.Errorf("no rule type is set"))
	}
	log.Printf("[INFO] Deleting casb malware rules ID: %v\n", (d.Id()))

	if _, err := casb_malware_rules.Delete(ctx, service, ruleType, id); err != nil {
		return diag.FromErr(err)
	}

	d.SetId("")
	log.Printf("[INFO] casb malware rules deleted")
	// Sleep for 2 seconds before potentially triggering the activation
	time.Sleep(2 * time.Second)

	// Check if ZIA_ACTIVATION is set to a truthy value before triggering activation
	if shouldActivate() {
		if activationErr := triggerActivation(ctx, zClient); activationErr != nil {
			return diag.FromErr(activationErr)
		}
	} else {
		log.Printf("[INFO] Skipping configuration activation due to ZIA_ACTIVATION env var not being set to true.")
	}

	return nil
}

func expandCasbMalwareRules(d *schema.ResourceData) casb_malware_rules.CasbMalwareRules {
	id, _ := getIntFromResourceData(d, "rule_id")

	// Retrieve the order and fallback to 1 if it's 0
	order := d.Get("order").(int)
	if order == 0 {
		log.Printf("[WARN] expandCasbMalwareRules: Rule ID %d has order=0. Falling back to order=1", id)
		order = 1
	}

	result := casb_malware_rules.CasbMalwareRules{
		ID:                    id,
		Name:                  d.Get("name").(string),
		Type:                  d.Get("type").(string),
		Order:                 order,
		State:                 d.Get("state").(string),
		Action:                d.Get("action").(string),
		ScanInboundEmailLink:  d.Get("scan_inbound_email_link").(string),
		QuarantineLocation:    d.Get("quarantine_location").(string),
		Buckets:               expandIDNameExtensionsSet(d, "buckets"),
		Labels:                expandIDNameExtensionsSet(d, "labels"),
		CloudAppTenants:       expandIDNameExtensionsSet(d, "cloud_app_tenants"),
		CloudAppTenantIDs:     expandIDNameExtensionsSet(d, "cloud_app_tenant_ids"),
		CasbEmailLabel:        expandIDNameExtensionsSetSingle(d, "casb_email_label"),
		CasbTombstoneTemplate: expandIDNameExtensionsSetSingle(d, "casb_tombstone_template"),
	}

	return result
}
